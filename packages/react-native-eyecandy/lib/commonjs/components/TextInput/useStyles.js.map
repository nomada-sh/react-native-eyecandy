{"version":3,"sources":["useStyles.tsx"],"names":["useStyles","color","focused","widthPaddingEnd","widthPaddingStart","value","dirty","hasError","fullWidth","palette","typography","dark","colors","c","input","fontSize","body","empty","undefined","padding","errorColor","error","backgroundColor","background","textColor","foreground","placeholderColor","placeholder","indicatorColor","indicator","iconColor","keyboardAppearance","styles","StyleSheet","create","container","width","inputContainer","height","borderWidth","borderRadius","overflow","flexDirection","borderStyle","borderColor","iconContainer","justifyContent","paddingHorizontal","icon","flex","medium","fontWeight","paddingEnd","paddingStart","inputPlaceholder","renderIcon","Icon","stroke"],"mappings":"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","sourcesContent":["import React, { useCallback } from 'react';\nimport { StyleSheet } from 'react-native';\n\nimport { useTheme, useColors } from '@nomada-sh/react-native-eyecandy-theme';\n\nimport type { TextInputIcon, TextInputProps } from './typings';\n\nexport default function useStyles({\n  color = 'default',\n  focused,\n  widthPaddingEnd,\n  widthPaddingStart,\n  value,\n  dirty = false,\n  hasError = false,\n  fullWidth = true,\n}: {\n  color?: TextInputProps['color'];\n  focused: boolean;\n  widthPaddingEnd: boolean;\n  widthPaddingStart: boolean;\n  value?: string;\n  dirty?: boolean;\n  hasError?: boolean;\n  fullWidth?: boolean;\n}) {\n  const { palette, typography, dark } = useTheme();\n  const colors = useColors(c => c.input[color]);\n  const fontSize = typography.body.fontSize;\n\n  const empty = dirty || value === undefined || value === '';\n\n  const padding = 16;\n\n  const errorColor = palette.error[200];\n\n  const backgroundColor = focused\n    ? colors.focused.background\n    : colors.background;\n\n  let textColor = colors.foreground;\n  textColor = hasError ? errorColor : textColor;\n\n  let placeholderColor = colors.placeholder;\n  placeholderColor = hasError ? errorColor : placeholderColor;\n\n  let indicatorColor = focused ? colors.focused.indicator : backgroundColor;\n  indicatorColor = hasError ? errorColor : indicatorColor;\n\n  let iconColor = focused ? indicatorColor : textColor;\n\n  const keyboardAppearance: TextInputProps['keyboardAppearance'] = dark\n    ? 'dark'\n    : 'light';\n\n  const styles = StyleSheet.create({\n        container: {\n          width: fullWidth ? '100%' : undefined,\n        },\n        inputContainer: {\n          height: 56,\n          borderWidth: 1,\n          backgroundColor,\n          borderRadius: 12,\n          overflow: 'hidden',\n          flexDirection: 'row',\n          borderStyle: 'solid',\n          borderColor: indicatorColor,\n        },\n        iconContainer: {\n          justifyContent: 'center',\n          paddingHorizontal: padding,\n        },\n        icon: {\n          fontSize: 20,\n          color: iconColor,\n        },\n        input: {\n          flex: 1,\n          color: textColor,\n          fontSize: fontSize.medium,\n          fontWeight: empty ? 'normal' : '700',\n          paddingEnd: widthPaddingEnd ? padding : 0,\n          paddingStart: widthPaddingStart ? padding : 0,\n        },\n        inputPlaceholder: {\n          color: placeholderColor,\n        },\n      })\n\n  const renderIcon = useCallback(\n    (Icon: TextInputIcon, stroke?: string) => {\n      return (\n        <Icon\n          size={styles.icon.fontSize}\n          stroke={stroke || styles.icon.color}\n        />\n      );\n    },\n    [styles.icon.color, styles.icon.fontSize],\n  );\n\n  return {\n    styles,\n    keyboardAppearance,\n    renderIcon,\n  };\n}\n"]}